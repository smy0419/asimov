// Copyright (c) 2018-2020. The asimov developers
// Copyright (c) 2013-2017 The btcsuite developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.
package asiutil

import (
	"bytes"
	"github.com/AsimovNetwork/asimov/common"
	"github.com/AsimovNetwork/asimov/txscript"
	"io"
	"math"
	"strconv"

	"github.com/AsimovNetwork/asimov/protos"
	"github.com/AsimovNetwork/asimov/vm/fvm/log"
)

// TxIndexUnknown is the value returned for a transaction index that is unknown.
// This is typically because the transaction has not been inserted into a block
// yet.
const TxIndexUnknown = -1

const TransferCreationIdx = math.MaxUint32 - 1

const TransferMintIdx = math.MaxUint32 - 2

const (
	//unknown,
	TxTypeUnknown int = 0

	//unsupported type, illegal tx type.
	TxTypeUnsupport int = 1

	// generated by vm, it happens when transferring coin in contract executions.
	TxTypeVM int = 2

	//standard tx that generated by wallet.
	TxTypeNormal int = 4
)

// Asimov coin asset
var AsimovAsset = protos.Asset{}

// Tx defines a bitcoin transaction that provides easier and more efficient
// manipulation of raw transactions.  It also memorizes the hash for the
// transaction on its first access so subsequent accesses don't have to repeat
// the relatively expensive hashing operations.
type Tx struct {
	msgTx   *protos.MsgTx // Underlying MsgTx
	txHash  *common.Hash  // Cached transaction hash
	txIndex int           // Position within a block or TxIndexUnknown
	txType  int
}

// MsgTx returns the underlying protos.MsgTx for the transaction.
func (t *Tx) MsgTx() *protos.MsgTx {
	// Return the cached transaction.
	return t.msgTx
}

// Hash returns the hash of the transaction.  This is equivalent to
// calling TxHash on the underlying protos.MsgTx, however it caches the
// result so subsequent calls are more efficient.
func (t *Tx) Hash() *common.Hash {
	// Return the cached hash if it has already been generated.
	if t.txHash != nil {
		return t.txHash
	}

	// Cache the hash and return it.
	hash := t.msgTx.TxHash()
	t.txHash = &hash
	return &hash
}

// GetInputHash returns hash of input from transaction
func (t *Tx) GetInputHash() []byte {
	return GenInputHash(t.MsgTx())
}

// Index returns the saved index of the transaction within a block.  This value
// will be TxIndexUnknown if it hasn't already explicitly been set.
func (t *Tx) Index() int {
	return t.txIndex
}

// SetIndex sets the index of the transaction in within a block.
func (t *Tx) SetIndex(index int) {
	t.txIndex = index
}

func (t *Tx) Type() int {
	if t.txType == TxTypeUnknown {
		for _, input := range t.msgTx.TxIn {
			if txscript.IsVtx(input.SignatureScript) {
				if t.txType == TxTypeUnknown {
					t.txType = TxTypeVM
				} else if t.txType != TxTypeVM {
					t.txType = TxTypeUnsupport
					break
				}
			} else {
				if t.txType == TxTypeUnknown {
					t.txType = TxTypeNormal
				} else if t.txType != TxTypeNormal {
					t.txType = TxTypeUnsupport
					break
				}
			}
		}
	}
	return t.txType
}

// NewTx returns a new instance of a bitcoin transaction given an underlying
// protos.MsgTx.  See Tx.
func NewTx(msgTx *protos.MsgTx) *Tx {
	return &Tx{
		msgTx:   msgTx,
		txIndex: TxIndexUnknown,
		txType:  TxTypeUnknown,
	}
}

// NewTxFromBytes returns a new instance of a bitcoin transaction given the
// serialized bytes.  See Tx.
func NewTxFromBytes(serializedTx []byte) (*Tx, error) {
	br := bytes.NewReader(serializedTx)
	return NewTxFromReader(br)
}

// NewTxFromReader returns a new instance of a bitcoin transaction given a
// Reader to deserialize the transaction.  See Tx.
func NewTxFromReader(r io.Reader) (*Tx, error) {
	// Deserialize the bytes into a MsgTx.
	var msgTx protos.MsgTx
	err := msgTx.Deserialize(r)
	if err != nil {
		return nil, err
	}

	t := Tx{
		msgTx:   &msgTx,
		txIndex: TxIndexUnknown,
		txType:  TxTypeUnknown,
	}
	return &t, nil
}

// merge normal tx and virtual tx into a single list, to match the order of stxo set.
// the virtual tx will follow the parent normal tx(that tx contains contract execution and generates virtual tx)
// for ex:
// tx1, tx2, tx3, tx4
// vtx2,vtx2-2, vtx3
// ---> tx1, tx2, vtx2, vtx2-2, tx3, vtx3, tx4
func MergeTxVtx(txs []*Tx, vtxs []*Tx) []*Tx {
	if vtxs == nil || len(vtxs) == 0 {
		return txs
	}

	alltxs := make([]*Tx, 0, len(txs)+len(vtxs))
	j := 0
	for _, vtx := range vtxs {
		for ; j < len(txs); j++ {
			if txs[j].Index() <= int(vtx.msgTx.Version) {
				alltxs = append(alltxs, txs[j])
			} else {
				break
			}
		}
		alltxs = append(alltxs, vtx)
	}
	for ; j < len(txs); j++ {
		alltxs = append(alltxs, txs[j])
	}

	log.Debug("merget tx and virtualtx sucess,", len(alltxs), cap(alltxs), len(txs), len(vtxs))
	return alltxs
}

// IsMintOrCreateInput returns operate type of input, mint or create
func IsMintOrCreateInput(in *protos.TxIn) bool {
	prevOut := in.PreviousOutPoint
	return (prevOut.Index == math.MaxUint32 || prevOut.Index == TransferCreationIdx || prevOut.Index == TransferMintIdx) && prevOut.Hash == common.Hash{}
}

// GenInputHash generates hash from txIn.PreviousOutPoint.Hash and txIn.PreviousOutPoint.Index
func GenInputHash(msgTx *protos.MsgTx) []byte {
	var buffer bytes.Buffer
	for _, txIn := range msgTx.TxIn {
		buffer.WriteString(txIn.PreviousOutPoint.Hash.UnprefixString())
		buffer.WriteString("-")
		buffer.WriteString(strconv.Itoa(int(txIn.PreviousOutPoint.Index)))
		buffer.WriteString("-")
	}
	return common.HashH(buffer.Bytes()).Bytes()
}
